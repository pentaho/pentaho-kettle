<!--===========================================================================
Copyright (c) 2008-2009, Pentaho Engineering Team
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the Pentaho Corporation nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY Pentaho Engineering Team ''AS IS'' AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL <copyright holder> BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
============================================================================-->
<!--===========================================================================
    == SUBFLOOR ==
    
    $Date: Wed Nov  6 16:13:57 UTC 2013 $
    Project Home: https://github.com/pentaho/subfloor/
    
    This file contains the default implementation of the ant tasks to 
    perform a build. This file should be included by the build.xml file 
    for your particular project. That build file should redefine any task 
    that is defined in subfloor.xml IF AND ONLY IF the function of the 
    task needs to be customized.
    
    FORMATTING: 
      ALIGNMENT: indent=2 spaces and wrap lines longer than 120 chars
      NAMING: targets intended for execution by a user are named single-word
              or hyphenated.  Internal targets use '.' notation.
    
    TO GET STARTED with your project, you will need this file in 
          your project's root directory along with three additional files:
          1. build.xml 
          2. build.properties
          3. ivy_settings.xml
          4. ivy.xml
          
          Below are some templates:
          
      === build.xml
    <project name="MyProject" basedir="." default="jar" xmlns:ivy="antlib:org.apache.ivy.ant" >
      <description>
        This build file is used to create the MyProject project and works with the subfloor.xml file.
      </description>

      <import file="subfloor.xml"/>
    </project>
  
    === build.properties
    project.revision=1.0-SNAPSHOT  #the version of your project.  This will appear in jar META-INF, dist artifact filenames and IVY revision metadata. 
    ivy.artifact.id=my-project   #IVY metadata describing the name of the artifact
    impl.title=My Project #English language version of your project name
    
============================================================================-->


<project name="subfloor" basedir="." default="default" xmlns:ivy="antlib:org.apache.ivy.ant">
  <description>
-------------------------------------------------------------------------------
     subfloor.xml provides tasks needed to perform a project build. 
     It is typically not used directly but imported by each project's build.xml
     file.  The build.xml file can override tasks when customization is required. 
      
MAIN TARGETS
============
  * clean / clean-all : 
    remove all artifacts of the build, clean-all adds the removal
    of any library or jar dependencies downloaded as part of the build
    
  * resolve :
    download/refresh library or jar dependencies needed for the build (uses Apache IVY)
    
  * compile :
    run javac on the project's source
    
  * jar :
    creates a jar file
    
  * dist :
    creates all project distributables
    
  * test :
    runs JUnit tests from your project's test source
    
SPECIAL TARGETS
============
  * publish-local :
    builds a jar for your project and registers it with the local artifact repository isolated 
    to your machine at $HOME/.ivy2/local.  Further executions of the the resolve target by this
    or other projects will find your published jar.
    
  * ivy-clean* :
    this family of targets helps reset your IVY environment in the event that you are having
    difficulty resolving dependencies
    
TYPICAL TARGET SEQUENCE
============    
  * clean-all resolve dist :
    a good start to build all project distributables from scratch.  Note that jar dependencies
    will not be downloaded unless you explicitly run the resolve target.  We made the resolution
    and retrieval completely discretionary since there are many situations in which
    you will not want to get or refresh dependencies, e.g. if you are offline with no Internet
    access.  In such case, you could just run "dist" if the set of jars you already have are 
    sufficient.
    
  </description>

  <!-- Load the properties files in the proper order -->
  <property file="override.properties"
            description="Properties customized for your development environment belong in this file.  This file will never be checked into the SCM." />
  <property file="build.properties"
            description="Properties customized for your particular project belong in this file." />

  <!-- =================================================================================
       Property Defaults
       Any of these properties can be overridden in either build.properties or override.properties
       =================================================================================-->

  <!-- Project meta properties -->
  <property name="impl.vendor" value="Pentaho Corporation" description="Jar file metadata describing the jar's vendor" />
  <property name="impl.productID"
            value=""
            description="Jar file metadata indicating the product ID (this is not the revision)" />

  <!-- Compile properties -->
  <property name="src.dir" value="${basedir}/src" description="Project source code directory" />
  <property name="bin.dir" value="${basedir}/bin" description="Base directory for all non-dist build output" />
  <property name="classes.dir"
            value="${bin.dir}/classes"
            description="Classes compiled from project source code are placed here" />
  <property name="lib.dir"
            value="${basedir}/lib"
            description="Directory that hosts Jar files required to compile project source.  (IVY will populate this directory with required jars)" />
  <property name="devlib.dir"
            value="${basedir}/dev-lib"
            description="Directory for developer to place development Jar files (not affected by clean targets)" />

  <!-- Compiler properties (passed directly to javac ant target) -->
  <property name="javac.debug"
            value="true"
            description="Indicates whether source should be compiled with debug information (passed to javac ant task)." />
  <property name="javac.deprecation"
            value="true"
            description="Indicates whether source should be compiled with deprecation information" />
  <property name="javac.source" value="6" description="Provide source compatibility with specified release" />
  <property name="javac.target" value="6" description="Generate class files for specific VM version" />
  <property name="javac.maxmemory" value="256M" description="Max memory alloted to java compile" />
  <property name="javac.xlint" value="-Xlint:all" />

  <!-- Third party Ant tasks and tools properties -->
  <property name="subfloor.resources.dir"
            value="${user.home}/.subfloor"
            description="Base dir for runtime jars that are required exclusively by the build process" />
  <property name="subfloor.tmp.dir"
            value="${subfloor.resources.dir}/tmp"
            description="Temporary space where files are prepared for installation" />
  <property name="antcontrib.build.cache.dir"
            value="${subfloor.resources.dir}/ant-contrib"
            description="Directory where the Ant-Contrib jar (and dependencies) is placed after it is auto-downloaded by the build" />
  <property name="svnant.use-javahl"
            value="false"
            description="Prefer JNI JavaHL binding over the command line client for native svn support" />
  <property name="svnant.use-svnkit"
            value="true"
            description="Prefer SVNKit binding over the command line client for native svn support (defaults to true)" />
  <property name="ivy.url"
            value="http://repo.pentaho.org/artifactory/repo/org/apache/ivy/ivy/2.3.0/ivy-2.3.0.jar"
            description="The URL to the current release of Apache IVY" />
	
  <!-- Enunciate properties -->
  <property name="enunciate.home" value="${basedir}/enunciate" />
  <property name="enunciate.bin.dir" value="${bin.dir}/enunciate" />


  <!-- Test properties -->
  <property name="junit.base.dir" value="${basedir}" description="Directory in which the junit test VM will be invoked" />
  <property name="testsrc.dir" value="${basedir}/test-src" description="Directory that hosts the test source files" />
  <property name="testlib.dir"
            value="${basedir}/test-lib"
            description="Directory for jar files needed during unit testing" />
  <property name="testbin.dir"
            value="${bin.dir}/test"
            description="Base directory for all compiler generated test output" />
  <property name="testclasses.dir"
            value="${testbin.dir}/classes"
            description="Classes compiled from project test code are placed here" />
  <property name="testreports.dir"
            value="${bin.dir}/reports/test"
            description="Base directory that holds all unit test report files" />
  <property name="testreports.xml.dir"
            value="${testreports.dir}/xml"
            description="Unit test xml reports are placed here" />
  <property name="testreports.html.dir"
            value="${testreports.dir}/html"
            description="Unit test html reports are placed here" />
  <property name="junit.haltonfailure" value="no" description="Fail the build if a test fails" />
  <property name="junit.haltonerror" value="no" description="Fail the build if a error occurs" />
  <property name="junit.maxmemory" value="256M" description="Heap size when Junit is run in fork mode" />
  <property name="junit.forkmode" 
            value="perTest" 
            description="Defines whether JUnit forks a new JVM for each test. Use 'once' for faster test runs, and 'perTest' for complete tests."/>
  <property name="headless.unittest" value="true" description="Runs the unit tests in headless mode" />

  <!-- Code Coverage properties -->
  <property name="instrumented.classes.dir"
            value="${testbin.dir}/instrumented-classes"
            description="Directory where instrumented project classes are placed for use by code coverage utility" />
  <property name="cobertura.version"
            value="1.9.4.1"
            description="The version of cobertura to use for code coverage" />
  <property name="cobertura.data.dir"
            value="${testbin.dir}/cobertura-bin"
            description="Temporary data directory used by Cobertura" />
  <property name="coberturareports.dir"
            value="${bin.dir}/reports/cobertura"
            description="Base directory for all generated Cobertura code coverage reports" />
  <property name="coberturareports.xml.dir"
            value="${coberturareports.dir}/xml"
            description="Cobertura xml reports are placed here" />
  <property name="coberturareports.html.dir"
            value="${coberturareports.dir}/html"
            description="Cobertura html reports are placed here" />

  <!-- Javadoc properties -->
  <property name="javadoc.dir"
            value="${bin.dir}/javadoc"
            description="Directory where generated javadoc will be placed" />
  <property name="javadoc.packagenames"
            value="org.mypackagename.*"
            description="This property is passed to the packagenames property of the javadoc ant task.  You should customize this for your project." />
  <property name="javadoc.zip.filename" value="${ivy.artifact.id}-${project.revision}-javadoc.zip" />
  <property name="javadoc.tar.filename" value="${ivy.artifact.id}-${project.revision}-javadoc.tar.gz" />

  <!-- Distribution and Assembly properties -->
  <property name="dist.dir"
            value="${basedir}/dist"
            description="Base directory for all project artifacts (jar, zip, tar.gz, etc...)" />
  <property name="license.dir"
            value="${basedir}"
            description="Base directory where this project's license files reside" />
  <property name="res.dir"
            value="${basedir}/res"
            description="Directory that holds resources not included in the source tree" />
  <property name="source.zip.filename" value="${ivy.artifact.id}-${project.revision}-sources.zip" />
  <property name="source.tar.filename" value="${ivy.artifact.id}-${project.revision}-sources.tar.gz" />
  <property name="source.publish" value="true" />
  
  <!-- Ivy properties -->
  <property name="ivy.settingsurl"
            value="file:${basedir}/ivysettings.xml"
            description="URL to the (common) ivysettings.xml.  This file is required by the build to configure IVY.  Note you must escape the ':' if this property exists in a .properties file" />
  <property name="ivyfile"
            value="ivy.xml"
            description="The name of the IVY xml file defining your project's dependencies" />
  <property name="ivy.artifact.group"
            value="mycompanyname"
            description="IVY metadata describing the originating company or organization" />
  <property name="ivy.artifact.pomfile"
            value="${dist.dir}/pom.xml"
            description="The path to the Maven pom file to deploy with the artifact" />
  <property name="ivy.artifact.ivyfilename"
            value="ivy.xml"
            description="The name of the IVY xml file to deploy with the artifact" />
  <property name="ivy.artifact.ivypathname"
            value="${dist.dir}/ivy.xml"
            description="The full path to the IVY xml file to deploy with the artifact" />
  <property name="ivy.reports.dir"
            value="${bin.dir}/reports/ivy"
            description="Base directory that holds all IVY dependency report files" />
  <property name="ivy.configs" value="*" description="Set of configs used for IVY reporting and checking operations" />
  <property name="ivy.use.symlinks" value="true" description="Flag indicating if Ivy should create symlinks when retrieving artifacts."/>

  <!-- Tattletale properties -->
  <property name="tattletale.url"
            value="http://repo.pentaho.org/artifactory/repo/jboss/tattletale/1.1.2.Final/tattletale-1.1.2.Final.zip"
            description="The URL from which to download tattletale" />
  <property name="tattletale.classname"
            value="org.jboss.tattletale.ant.ReportTask"
            description="The name of the class which will run the tattletale reports" />
  <property name="tattletale.reports.dir"
            value="${bin.dir}/reports/tattletale"
            description="Base directory that holds the output of the tattletale reports" />
  <property name="tattletale.configfile"
            value=""
            description="The configuration file for the tattletale report" />

  <!-- Sonar properties -->
  <property name="sonar.url"
            value="http://repo1.maven.org/maven2/org/codehaus/sonar-plugins/sonar-ant-task/1.2/sonar-ant-task-1.2.jar"/>
  <property name="sonar.classname"
          value="org.sonar.ant.SonarTask"/>

  <!-- Load the manifest file (if any) as a properties file -->
  <property name="dist.manifest.file"
            value="${dist.dir}/MANIFEST.MF"
            description="The manifest file that will be generated as part of the build" />
  <property name="manifest.file"
            value="${res.dir}/META-INF/MANIFEST.MF"
            description="The location of the MANIFEST.MF file for this application." />
  <property file="${manifest.file}"
            description="Loads the manifest information from the manifest file as a properties file." />

  <!-- Set the project revision number to the value in the manifest file (if it has not
       been specified in the properties file -->
  <property name="project.revision"
            value="${Implementation-Version}"
            description="Sets the version number of the project based on the Implementation-Version found in the manifest file (if one is supplied and nothing is specified in the build.properties)" />
  <fail message="A project revision number has not been determined!">
    <condition>
      <matches string="${project.revision}" pattern="\$\{.*\}" />
    </condition>
  </fail>

  <!-- Set the project title to the value in the manifest file (if it has not
       been specified in the properties file -->
  <property name="impl.title"
            value="${Implementation-Title}"
            description="Sets the title of the project based on the Implementation-Title found in the manifest file (if one is supplied and nothing is specified in the build.properties)" />
  <fail message="A project title has not been determined!">
    <condition>
      <matches string="${impl.title}" pattern="\$\{.*\}" />
    </condition>
  </fail>

  <!-- Build Mode properties -->
  <property name="release" value="false" description="Set this to true if you want to generate a release artifact" />

  <!-- Ivy should only use symlinks if we're not in release mode -->
  <condition property="ivy.use.symlinks.internal">
    <and>
      <isfalse value="${release}"/>
      <istrue value="${ivy.use.symlinks}"/>
    </and>
  </condition>

  <!-- Set the os property -->
  <condition property="isLinux">
    <os family="unix" />
  </condition>
  <condition property="isWindows">
    <os family="windows" />
  </condition>
  <condition property="isMac">
    <os family="mac" />
  </condition>

  <condition property="os.classifier" value="win">
    <os family="windows" />
  </condition>
  <condition property="os.classifier" value="mac">
    <os family="mac" />
  </condition>
  <condition property="os.classifier" value="linux">
    <os family="unix" />
  </condition>
  <property name="os.classifier" value="unsupported" />

  <!-- Setup the compile classpath -->
  <path id="classpath">
    <fileset dir="${devlib.dir}">
      <include name="**/*.jar" />
    </fileset>
    <fileset dir="${lib.dir}">
      <include name="**/*.jar" />
    </fileset>
  </path>

  <!-- Setup the classpath used for testing -->
  <path id="test.classpath">
    <pathelement path="${testclasses.dir}" />
    <pathelement path="${classes.dir}" />
    <fileset dir="${devlib.dir}">
      <include name="**/*.jar" />
    </fileset>
    <fileset dir="${testlib.dir}">
      <include name="**/*.jar" />
    </fileset>
    <fileset dir="${lib.dir}">
      <include name="**/*.jar" />
    </fileset>
  </path>


  <!--=======================================================================
      default
      
      The target that is run if no target is given
      ====================================================================-->
  <target name="default" depends="build" />


  <!--=======================================================================
      build
      
      Runs a typical build process to create the project locally
      ====================================================================-->
  <target name="build" depends="clean-all,resolve,cobertura,dist-source,dist" />


  <!--=======================================================================
      build-testless
      
      Runs a typical build process to create the project locally (no testing)
      ====================================================================-->
  <target name="build-testless" depends="clean-all,resolve,dist-source,dist" />


  <!--=======================================================================
      continuous
      
      Runs a typical continuous integration build including project dist,
      test, and coverage artifacts
      ====================================================================-->
  <target name="continuous" depends="build,publish" />


  <!--=======================================================================
      continuous-testless
      
      Runs a typical continuous integration build including project dist,
      and coverage artifacts
      ====================================================================-->
  <target name="continuous-testless" depends="build-testless,publish" />


  <!--=======================================================================
      install-antcontrib
      
      (Fetches and) installs ant-contrib tasks.
      ====================================================================-->
  <target name="install-antcontrib" depends="antcontrib.download-check">
    <taskdef resource="net/sf/antcontrib/antlib.xml">
      <classpath>
        <fileset dir="${antcontrib.build.cache.dir}">
          <include name="*.jar" />
        </fileset>
      </classpath>
    </taskdef>
  </target>


  <!--=======================================================================
      antcontrib.download-check
      
      Fetches ant-contrib from sourceforge if it is not already present
      ====================================================================-->
  <target name="antcontrib.download-check">
    <condition property="antcontrib.available">
      <and>
        <available file="${antcontrib.build.cache.dir}" />
        <available classname="net.sf.antcontrib.logic.IfTask">
          <classpath>
            <fileset dir="${antcontrib.build.cache.dir}">
              <include name="*.jar" />
            </fileset>
          </classpath>
        </available>
      </and>
    </condition>
    <antcall target="antcontrib.download" />
  </target>


  <!--=======================================================================
      antcontrib.download
      
      Fetches ant-contrib from sourceforge
      ====================================================================-->
  <target name="antcontrib.download" unless="antcontrib.available">
    <mkdir dir="${subfloor.tmp.dir}" />
    <get src="http://downloads.sourceforge.net/ant-contrib/ant-contrib-1.0b3-bin.zip"
         dest="${subfloor.tmp.dir}/antcontrib.zip"
         usetimestamp="true" />
    <unzip src="${subfloor.tmp.dir}/antcontrib.zip" dest="${subfloor.tmp.dir}">
      <patternset>
        <include name="**/*.jar" />
      </patternset>
    </unzip>
    <copy todir="${antcontrib.build.cache.dir}">
      <fileset dir="${subfloor.tmp.dir}/ant-contrib">
        <include name="**/*.jar" />
      </fileset>
    </copy>
  </target>


  <!--=======================================================================
      init
      
      Ensures that all the required directories exist before processing
      a build.
      ====================================================================-->
  <target name="init">
    <mkdir dir="${classes.dir}" />
    <mkdir dir="${dist.dir}" />
    <mkdir dir="${lib.dir}" />
    <mkdir dir="${devlib.dir}" />
    <mkdir dir="${testlib.dir}" />
  </target>


  <!--=======================================================================
    install-svnant
    
    (Fetches and) installs the SVN ANT for use by this ant script
    ====================================================================-->
  <target name="install-svnant" depends="install-ivy">
    <if>
      <istrue value="${svnant.isinstalled}" />
      <then>
        <echo message="Skipping SVN ANT install.  SVN ANT has already been configured by the build" />
      </then>
      <else>
        <taskdef-with-ivy organisation="tigris"
                          module="svnant"
                          revision="1.3.0"
                          resource="org/tigris/subversion/svnant/svnantlib.xml"
                          classname="org.tigris.subversion.svnant.SvnTask" />
        <property name="svnant.isinstalled" value="true" />
      </else>
    </if>
  </target>


  <!--=======================================================================
        test-svnant
    
        Tests SVN by printing out the repository
        ====================================================================-->
  <target name="test-svnant" depends="install-svnant">
    <svn javahl="${svnant.use-javahl}" svnkit="${svnant.use-svnkit}">
      <wcVersion path="." />
    </svn>
    <echo message="Subversion repository url: ${repository.url}" />
  </target>


  <!--=======================================================================
        svn-revision
    
        Prints and sets the SVN revision for the repository at the current dir (if svn.revision is not set)
        ====================================================================-->
  <target name="svn-revision" depends="install-svnant">

    <svn javahl="${svnant.use-javahl}" svnkit="${svnant.use-svnkit}">
      <status path="." revisionProperty="svn.revision" />
    </svn>
    <echo message="Subversion repository revision: ${svn.revision}" />
  </target>


  <!--=======================================================================
        set-build.id
    
        Sets a property build.id to the either "development" or the svn revision
        if in release mode
        ====================================================================-->
  <target name="set-build.id" unless="build.id" depends="install-antcontrib">
    <if>
      <istrue value="${release}" />
      <then>
        <antcallback target="svn-revision" return="svn.revision" />
        <property name="build.id" value="${svn.revision}" />
      </then>
      <else>
        <property name="build.id" value="development" />
      </else>
    </if>
  </target>

  <!--=================================================================================
       version-properties: common Ant driven version file generation.  Projects that produce
       a package or packages should run this target.  Projects that produce
       jars only should NOT.
   ===================================================================================-->
  <target name="version-properties" depends="set-build.id">
    <tstamp>
      <format property="build.time" pattern="yyyy/MM/dd hh:mm aa" />
    </tstamp>
    <propertyfile file="version.properties" comment="Release Build version info">
      <entry key="release.major.number" value="${release.major.number}" />
      <entry key="release.minor.number" value="${release.minor.number}" />
      <entry key="release.milestone.number" value="${release.milestone.number}" />
      <entry key="release.candidate.token" value="${release.candidate.token}" />
      <entry key="impl.vendor" value="${impl.vendor}" />
      <entry key="impl.version"
             value="${release.major.number}.${release.minor.number}.${release.milestone.number}.${build.id}" />
      <entry key="impl.title" value="${impl.title}" />
      <entry key="buildDate" value="${build.time}" />
      <entry key="svn.revision" value="${build.id}" />
      <entry key="release.build.number" default="0" type="int" operation="+" value="1" pattern="0000" />
    </propertyfile>
    <property file="${basedir}/version.properties" />
  </target>


  <!--=======================================================================
      install-ivy 
      
      Fetches and installs IVY ant tasks if not already installed 
      ====================================================================-->
  <target name="install-ivy" depends="install-antcontrib">
    <if>
      <istrue value="${ivy.isinstalled}" />
      <then>
        <echo message="Skipping IVY install.  IVY has already been configured by the build" />
      </then>
      <else>
        <download-antlib name="ivy" url="${ivy.url}" classname="org.apache.ivy.ant.IvyTask" extension="jar" />
        <taskdef resource="org/apache/ivy/ant/antlib.xml" uri="antlib:org.apache.ivy.ant">
          <classpath>
            <fileset dir="${subfloor.resources.dir}/ivy">
              <include name="*.jar" />
            </fileset>
          </classpath>
        </taskdef>
        <ivy:settings url="${ivy.settingsurl}" />
        <property name="ivy.isinstalled" value="true" />
      </else>
    </if>
  </target>


  <!--=======================================================================
      ivy.check-releasable
      
      Verifies that there are no SNAPSHOT dependencies defined in the ivy xml.
      If there are SNAPSHOTS, fail the release build.
      ====================================================================-->
  <target name="ivy.check-releasable" depends="install-ivy, install-antcontrib">
    <if>
      <istrue value="${release}" />
      <then>
        <sequential>
          <ivy:artifactproperty conf="${ivy.configs}" name="dep.[module]/[artifact]-[revision]" value="[revision]" />

          <propertyselector property="violators" match="dep\..*SNAPSHOT.*" select="\0" casesensitive="false" />

          <fail if="violators"
                message="Release not possible, you have dependencies on non-released artifacts: ${violators}" />
        </sequential>
      </then>
    </if>
  </target>


  <!--=======================================================================
      resolve
      
      Using ivy and the dependencies for the project (defined in the ivy.xml
      file), this task will retrieve the needed files and place them into 
      the defined directories.
      ====================================================================-->
  <target name="resolve"
          depends="resolve-default, resolve-test, ivy.check-releasable"
          description="Retrieves all the dependent libraries" />

  <target name="resolve-init" unless="resolve-init.skip" depends="install-ivy">
    <!-- If this is the 1st time through resolve-init, then we need to clean up the jars
-->
    <antcall target="clean-jars" />
    <property name="resolve-init.skip" value="" />
  </target>

  <target name="resolve-default" depends="resolve-default.default,resolve-default.composite"/>

  <!-- 
  This target resolves the default IVY configuration as a composite of child configurations.
  You should set ivy.default.sub-configs in your build.properties only if you want your default
  configuration to be treated as a composite of two or more child configurations.
  To turn this on, set ivy.default.sub-configs property in your build.properties, e.g.
  ivy.default.sub-configs=external,internal
  Note: the parent config "default" proper will not be resolved
  -->
  <target name="resolve-default.composite" depends="install-antcontrib,resolve-init" if="ivy.default.sub-configs">
    <for list="${ivy.default.sub-configs}" param="conf">
      <sequential>
        <ivy:resolve file="${ivyfile}" conf="default_@{conf}" />
        <ivy:retrieve conf="default_@{conf}" pattern="${lib.dir}/@{conf}/[module]-[revision](-[classifier]).[ext]" symlink="${ivy.use.symlinks.internal}" />
      </sequential>
    </for>
  </target>

  <target name="resolve-default.default" depends="resolve-init" unless="ivy.default.sub-configs">
    <ivy:resolve file="${ivyfile}" conf="default" />
    <ivy:retrieve conf="default" pattern="${lib.dir}/[module]-[revision](-[classifier]).[ext]" symlink="${ivy.use.symlinks.internal}" />
  </target>

  <target name="resolve-test" depends="resolve-init">
    <ivy:resolve file="${ivyfile}" conf="test" />
    <ivy:retrieve conf="test" pattern="${testlib.dir}/[module]-[revision](-[classifier]).[ext]" symlink="${ivy.use.symlinks.internal}" />
  </target>

  <target name="resolve-enunciate" depends="resolve-init">
    <ivy:resolve file="${ivyfile}" conf="enunciate" />
    <ivy:retrieve conf="enunciate" pattern="${basedir}/enunciate/lib/[module]-[revision](-[classifier]).[ext]" />
  </target>

  <target name="resolve-codegen" depends="resolve-init">
    <ivy:resolve file="${ivyfile}" conf="codegen" />
    <ivy:retrieve conf="codegen" pattern="${lib.dir}/[module]-[revision](-[classifier]).[ext]" symlink="${ivy.use.symlinks.internal}" />
  </target>

  <target name="resolve-runtime" depends="resolve-init">
    <ivy:resolve file="${ivyfile}" conf="runtime" />
    <ivy:retrieve conf="runtime" pattern="${lib.dir}/[module]-[revision](-[classifier]).[ext]" symlink="${ivy.use.symlinks.internal}" />
  </target>


  <!--=======================================================================
      ivy-clean-cache
      
      Cleans the IVY cache.  You are erasing IVY's memory.  Run this if you 
      want to force IVY to go fetch all your project dependencies from scratch.
      WARNING: this will affect all IVY projects, not just the current workspace
      ====================================================================-->
  <target name="ivy-clean-cache" depends="install-ivy">
    <ivy:cleancache />
  </target>


  <!--=======================================================================
      ivy-clean-local
      
      Completely cleans your local repository of any files published locally
      by way of publish-local.
      WARNING: this is a global action and will affect other IVY projects
      currently referencing a locally published dependency
      ====================================================================-->
  <target name="ivy-clean-local" depends="install-ivy">
    <delete dir="${ivy.local.default.root}/" />
  </target>


  <!--=======================================================================
      ivy-clean-by-name
      
      Cleans your IVY cache and local repository of specific files.
      WARNING: this is a global action and will affect other IVY projects
      currently referencing a locally published dependency
      ====================================================================-->
  <target name="ivy-clean-pentaho" depends="install-ivy">
    <mkdir dir="${ivy.local.default.root}" />
    <!-- just in case it doesn't exist -->
    <for param="dir">
      <path>
        <dirset dir="${ivy.local.default.root}" includes="*${ivy.clean.pattern}*" />
        <dirset dir="${ivy.default.ivy.user.dir}/cache" includes="*${ivy.clean.pattern}*" />
      </path>
      <sequential>
        <delete dir="@{dir}" includeemptydirs="true" />
      </sequential>
    </for>
    <for param="file">
      <path>
        <fileset dir="${ivy.local.default.root}" includes="*${ivy.clean.pattern}*" />
        <fileset dir="${ivy.default.ivy.user.dir}/cache" includes="*${ivy.clean.pattern}*" />
      </path>
      <sequential>
        <delete file="@{file}" />
      </sequential>
    </for>
  </target>


  <!--=======================================================================
      ivy-report
      
      Generates an IVY dependency report for this project. 
      ====================================================================-->
  <target name="ivy-report" depends="install-ivy">
    <ivy:resolve file="${ivyfile}" conf="${ivy.configs}" />
    <ivy:report xml="true" todir="${ivy.reports.dir}" />
  </target>


  <!--=======================================================================
      publish-local-nojar
      
      Publishes the jar file for this project to the user's local repository
      for download by other projects currently being executed on the user's
      system.
      ====================================================================-->
  <target name="publish-local-nojar" depends="install-ivy,publish-local-nojar.internal">
    <if>
      <equals arg1="${tests.publish}" arg2="true" />
      <then>
        <antcall target="publish-local-nojar.internal">
          <param name="ivy.artifact.id" value="${ivy.artifact.id}-test"/>
        </antcall>
      </then>
    </if>
    <antcall target="publish-local-nojar.post"/>
  </target>

  <!--=======================================================================
      publish-local-nojar.post this target is invoked after the normal set of publish-local-nojar
      is completed, override this to perform additional publishing in extensions of subfloor, etc
      ====================================================================-->
  <target name="publish-local-nojar.post">
  </target>
  
  <target name="publish-local-nojar.internal" depends="install-ivy">
    <ivy:resolve file="${ivy.artifact.ivyfilename}" />
    <ivy:publish resolver="local" pubrevision="${project.revision}" overwrite="true" forcedeliver="true" warnonmissing="yes" haltonmissing="no">
      <artifacts pattern="${dist.dir}/[artifact]-[revision](-[classifier]).[ext]" />
    </ivy:publish>
  </target>

  <!--=======================================================================
      publish-local
      
      Builds and publishes the jar file for this project to the user's 
      local repository for download by other projects currently being 
      executed on the user's system.
      ====================================================================-->
  <target name="publish-local"
          depends="dist, dist-source, publish-local-nojar"
          description="Builds and publishes the jar file to the local repository" />


  <!--=======================================================================
        publish
    
        Creates and publishes the jar file for this project to a Maven2 
        repository. 
        ====================================================================-->
  <target name="publish" depends="dist, dist-source, publish-nojar">
  </target>


  <!--=======================================================================
      publish-nojar
      
      Publishes the jar file for this project to a Maven2 repository.
      ====================================================================-->
  <target name="publish-nojar" depends="install-antcontrib,create-pom,ivy.deliver,publish-nojar.internal">
    <if>
      <equals arg1="${tests.publish}" arg2="true" />
      <then>
        <antcall target="publish-nojar.internal">
          <param name="ivy.artifact.id" value="${ivy.artifact.id}-test"/>
        </antcall>
      </then>
    </if>
  </target>

  <target name="publish-nojar.internal" depends="install-antcontrib,create-pom,ivy.deliver">
    <antcall target="maven-publish-dependencies">
      <param name="publish.groupId" value="${ivy.artifact.group}" />
      <param name="publish.artifactId" value="${ivy.artifact.id}" />
      <param name="publish.version" value="${project.revision}" />
      <param name="publish.file" value="${ivy.artifact.ivypathname}" />
    </antcall>

    <if>
      <equals arg1="${source.publish}" arg2="true" />
        <then>
          <antcall target="maven-publish-sources">
            <param name="publish.groupId" value="${ivy.artifact.group}" />
            <param name="publish.artifactId" value="${ivy.artifact.id}" />
            <param name="publish.version" value="${project.revision}" />
            <param name="publish.file" value="${dist.dir}/${ivy.artifact.id}-${project.revision}-sources.jar" />
          </antcall>
        </then>
    </if>

    <antcall target="maven-publish-artifact">
      <param name="publish.pomFile" value="${ivy.artifact.pomfile}" />
      <param name="publish.file" value="${dist.dir}/${ivy.artifact.id}-${project.revision}.jar" />
    </antcall>

    <antcall target="maven-publish.post"/>
    
  </target>

  <!-- Override this if anything is needed to be done after the standard parts of publish are completed -->
  <!-- Such as:  publishing non-standard/extended artifacts, etc -->
  <target name="maven-publish.post"/>
  
  <!--=======================================================================
        ivy.deliver
    
        Creates a publishable version of the ivy dependencies file, ivy.xml
        ====================================================================-->
  <target name="ivy.deliver" depends="resolve">
    <ivy:deliver conf="*(public)" deliverpattern="${dist.dir}/ivy.xml" />
  </target>


  <!--=======================================================================
      maven-publish-dependencies
      
      A function that deploys an ivy.xml file to a maven repository
      ====================================================================-->
  <target name="maven-publish-dependencies" depends="install-antcontrib">
    <sequential>
      <fail message="No file found at: ${publish.file}">
        <condition>
          <not>
            <available file="${publish.file}" />
          </not>
        </condition>
      </fail>
      <echo message="Publishing ${publish.file} to ${ivy.repository.publish}..." />
      <if>
        <isset property="isWindows" />
        <then>
          <exec executable="cmd" failonerror="true">
            <arg value="/c" />
            <arg value="mvn.bat" />
            <arg value="deploy:deploy-file" />
            <arg value="-DrepositoryId=${ivy.repository.id}" />
            <arg value="-Durl=${ivy.repository.publish}" />
            <arg value="-DgroupId=${publish.groupId}" />
            <arg value="-DartifactId=${publish.artifactId}" />
            <arg value="-Dversion=${publish.version}" />
            <arg value="-Dpackaging=ivy.xml" />
            <arg value="-Dfile=${publish.file}" />
          </exec>
        </then>
        <else>
          <exec executable="mvn" failonerror="true">
            <arg value="deploy:deploy-file" />
            <arg value="-DrepositoryId=${ivy.repository.id}" />
            <arg value="-Durl=${ivy.repository.publish}" />
            <arg value="-DgroupId=${publish.groupId}" />
            <arg value="-DartifactId=${publish.artifactId}" />
            <arg value="-Dversion=${publish.version}" />
            <arg value="-Dpackaging=ivy.xml" />
            <arg value="-Dfile=${publish.file}" />
            <arg value="-e" />
          </exec>
        </else>
      </if>
    </sequential>
  </target>


  <!--=======================================================================
      maven-publish-artifact
      
      A function that deploys an artifact to a maven repository
      ====================================================================-->
  <target name="maven-publish-artifact" depends="install-antcontrib">
    <sequential>
      <fail message="No file found at: ${publish.file}">
        <condition>
          <not>
            <available file="${publish.file}" />
          </not>
        </condition>
      </fail>
      <echo message="Publishing ${publish.file} to ${ivy.repository.publish}..." />
      <if>
        <isset property="isWindows" />
        <then>
          <exec executable="cmd" failonerror="true">
            <arg value="/c" />
            <arg value="mvn.bat" />
            <arg value="deploy:deploy-file" />
            <arg value="-DrepositoryId=${ivy.repository.id}" />
            <arg value="-Durl=${ivy.repository.publish}" />
            <arg value="-DpomFile=${publish.pomFile}" />
            <arg value="-Dfile=${publish.file}" />
          </exec>
        </then>
        <else>
          <exec executable="mvn" failonerror="true">
            <arg value="deploy:deploy-file" />
            <arg value="-DrepositoryId=${ivy.repository.id}" />
            <arg value="-Durl=${ivy.repository.publish}" />
            <arg value="-DpomFile=${publish.pomFile}" />
            <arg value="-Dfile=${publish.file}" />
          </exec>
        </else>
      </if>
    </sequential>
  </target>


  <!--=======================================================================
      maven-publish-sources
      
      A function that deploys a java-sources artifact to a maven repository
      ====================================================================-->
  <target name="maven-publish-sources" depends="install-antcontrib">
    <sequential>
      <fail message="No file found at: ${publish.file}">
        <condition>
          <not>
            <available file="${publish.file}" />
          </not>
        </condition>
      </fail>
      <echo message="Publishing ${publish.file} to ${ivy.repository.publish}..." />
      <if>
        <isset property="isWindows" />
        <then>
          <exec executable="cmd" failonerror="true">
            <arg value="/c" />
            <arg value="mvn.bat" />
            <arg value="deploy:deploy-file" />
            <arg value="-DrepositoryId=${ivy.repository.id}" />
            <arg value="-Durl=${ivy.repository.publish}" />
            <arg value="-DgroupId=${publish.groupId}" />
            <arg value="-DartifactId=${publish.artifactId}" />
            <arg value="-Dversion=${publish.version}" />
            <arg value="-DgeneratePom=true" />
            <arg value="-Dpackaging=java-source" />
            <arg value="-Dfile=${publish.file}" />
          </exec>
        </then>
        <else>
          <exec executable="mvn" failonerror="true">
            <arg value="deploy:deploy-file" />
            <arg value="-DrepositoryId=${ivy.repository.id}" />
            <arg value="-Durl=${ivy.repository.publish}" />
            <arg value="-DgroupId=${publish.groupId}" />
            <arg value="-DartifactId=${publish.artifactId}" />
            <arg value="-Dversion=${publish.version}" />
            <arg value="-DgeneratePom=true" />
            <arg value="-Dpackaging=java-source" />
            <arg value="-Dfile=${publish.file}" />
          </exec>
        </else>
      </if>
    </sequential>
  </target>


  <!--=======================================================================
      create-pom
      
      Creates the POM file for publishing the jar file to a Maven2 repository.
      ====================================================================-->
  <target name="create-pom" depends="install-ivy">
    <ivy:makepom ivyfile="${ivyfile}" pomfile="${dist.dir}/pom.xml">
      <mapping conf="default" scope="compile" />
      <mapping conf="runtime" scope="runtime" />
    </ivy:makepom>
  </target>


  <!--=======================================================================
      clean-jars
      
      Removes all the libraries that have been downloaded for this project
      using the ivy dependencies.
      ====================================================================-->
  <target name="clean-jars">
    <delete dir="${lib.dir}" />
    <delete dir="${testlib.dir}" />
  </target>


  <!--=======================================================================
      clean
      
      Removes all the files generated from the build process.
      ====================================================================-->
  <target name="clean"
          description="Cleans all the files generated from a build with the exception of IVY-downloaded jars (see clean-all)"
          depends="clean-tests, clean-cobertura, clean-sonar, clean-javadoc, clean-dist">
    <delete dir="${classes.dir}" />
    <delete dir="${bin.dir}" />
  </target>


  <!--=======================================================================
      clean-dist
      
      Removes all dist artifacts
      ====================================================================-->
  <target name="clean-dist">
    <delete dir="${dist.dir}" />
  </target>


  <!--=======================================================================
      clean-all
      
      Removes all the libraries that have been downloaded for this project
      in the workspace's lib dirs as well as all the files 
      generated from the build process.
      ====================================================================-->
  <target name="clean-all" depends="clean,clean-jars" description="Cleans all the generated and dependency files" />


  <!--=======================================================================
      copy-license-lgpl
      
      Copies the LGPL license file into the binary directory.
      ====================================================================-->
  <target name="copy-license-lgpl" if="lgpl-license-avail">
    <copy todir="${classes.dir}/META-INF">
      <fileset dir="${license.dir}" includes="lgpl-2.1.txt" />
    </copy>
  </target>


  <!--=======================================================================
      copy-license-gpl-parent
      
      Copies the GPL license file from the parent directory into the 
      binary directory.
      ====================================================================-->
  <target name="copy-license-gpl" if="gpl-license-avail">
    <copy todir="${classes.dir}/META-INF">
      <fileset dir="${license.dir}" includes="gpl-2.0.txt" />
    </copy>
  </target>


  <!--=======================================================================
      compile
      
      Compiles the source code (using the specified options) into the 
      binary directory.
      
      NOTE: This contains multiple sub-tasks which will occur in the 
            following order (this is provided for easier overriding by
            the build.xml which will include this file)...
        - compile.pre      : anything needed to prep for compile
        - compile.compile  : the actual compilation step
        - compile.src_copy : copying the source into the bin directory
        - compile.res_copy : copying the resources into the bin directory
        - compile.lic_copy : copying the license information into the bin directory
        - compile.post     : anything needed after the compile is done 
      ====================================================================-->
  <target name="compile"
          depends="init, compile.pre, compile.compile, compile.src_copy, compile.res_copy, compile.lic_copy, compile.post"
          description="Performs all the steps to prepare the bin directory with a complete compilation" />


  <!--=======================================================================
      compile.pre
      
      Prepares to perform the compile.
      ====================================================================-->
  <target name="compile.pre" />


  <!--=======================================================================
      compile.compile
      
      Performs the actual compile
      ====================================================================-->
  <target name="compile.compile" depends="init">
    <javac destdir="${classes.dir}"
           debug="${javac.debug}"
           deprecation="${javac.deprecation}"
           fork="true"
           memorymaximumsize="${javac.maxmemory}"
           source="${javac.source}"
           target="${javac.target}">
      <classpath>
        <path refid="classpath" />
      </classpath>
      <src path="${src.dir}" />
      <compilerarg value="${javac.xlint}" />
    </javac>
  </target>


  <!--=======================================================================
      compile.res_copy
      
      Copies any needed resources into the classes directory.  Will not
      duplicate copying of resources from src tree (handled by compile.src_copy
      if jar.include.source is set.
      ====================================================================-->
  <target name="compile.res_copy" depends="install-antcontrib">
    <if>
      <available file="${res.dir}" />
      <then>
        <copy todir="${classes.dir}">
          <fileset dir="${res.dir}" />
        </copy>
      </then>
    </if>

    <if>
      <not>
        <isset property="jar.include.source" />
      </not>
      <then>
        <copy todir="${classes.dir}" flatten="false">
          <fileset dir="${src.dir}" excludes="**/*.java" />
        </copy>
      </then>
    </if>
  </target>


  <!--=======================================================================
      compile.src_copy
      
      Copies the source files to the bin directory
      NOTE: if the dont.copy.source variable exists, this step will be
            skipped!
      ====================================================================-->
  <target name="compile.src_copy" depends="init" if="jar.include.source">
    <copy todir="${classes.dir}" flatten="false">
      <fileset dir="${src.dir}" />
    </copy>
  </target>


  <!--=======================================================================
      compile.lic_copy
      
      Copies the license file(s) into the bin directory
      ====================================================================-->
  <target name="compile.lic_copy" depends="init">
    <condition property="lgpl-license-avail">
      <available file="${license.dir}/lgpl-2.1.txt" />
    </condition>
    <antcall target="copy-license-lgpl" />
    <condition property="gpl-license-avail">
      <available file="${license.dir}/gpl-2.0.txt" />
    </condition>
    <antcall target="copy-license-gpl" />
  </target>


  <!--=======================================================================
      compile.post
      
      Performs any needed post-compile tasks
      ====================================================================-->
  <target name="compile.post" />


  <!--=======================================================================
      jar
      
      Creates a jar file from the bin directory
      ====================================================================-->
  <target name="jar"
          depends="jar.main,jar.test"
          description="Jars up the bin directory after a compile">
  </target>

  <!-- jar the tests ONLY IF tests.publish it true -->
  <!-- if the compile-tests target is in the dependency list for this target, -->
  <!-- it will get executed no matter what the value of tests.publish is      -->
  <target name="jar.test"
          if="tests.publish">
    <antcall target="compile-tests" />
    <jar destfile="${dist.dir}/${ivy.artifact.id}-test-${project.revision}.jar" manifest="${dist.manifest.file}">
      <fileset dir="${testclasses.dir}"/>
    </jar>
  </target>

  <target name="jar.main"
          depends="compile,set-build.id,generate.manifest">
    <jar destfile="${dist.dir}/${ivy.artifact.id}-${project.revision}.jar" manifest="${dist.manifest.file}">
      <fileset dir="${classes.dir}" />
    </jar>
  </target>

  <!--=======================================================================
      generate.manifest
      
      Creates a new manifest file if one is not specified, or updates
      an existing manifest file if one is specified.
      ====================================================================-->
  <target name="generate.manifest" depends="init,set-build.id">
    <delete file="${dist.manifest.file}" />
    <touch file="${dist.manifest.file}" />
    <copy file="${manifest.file}" tofile="${dist.manifest.file}" overwrite="true" failonerror="false" />

    <manifest file="${dist.manifest.file}" mode="update">
      <attribute name="Implementation-Title" value="${impl.title}" />
      <attribute name="Implementation-Version" value="${project.revision}.${build.id}" />
      <attribute name="Implementation-Vendor" value="${impl.vendor}" />
      <attribute name="Implementation-ProductID" value="${impl.productID}" />
    </manifest>
  </target>


  <!--=======================================================================
      dist-source
      
      Generates zip and targz distributions of the javadoc
      ====================================================================-->
  <target name="dist-source" depends="source.jar, source.zip, source.targz" />


  <!--=======================================================================
      source.jar
      
      Creates a jar of the project source for distribution
      ====================================================================-->
  <target name="source.jar" depends="init,install-antcontrib">
    <jar jarfile="${dist.dir}/${ivy.artifact.id}-${project.revision}-sources.jar" basedir="${src.dir}" />
    <if>
      <equals arg1="${tests.publish}" arg2="true" />
      <then>
        <jar jarfile="${dist.dir}/${ivy.artifact.id}-test-${project.revision}-sources.jar" basedir="${src.dir}" />
      </then>
    </if>
  </target>

  <!--=======================================================================
      source.zip
      
      Creates a zip of the project source for distribution
      ====================================================================-->
  <target name="source.zip" depends="init">
    <jar jarfile="${dist.dir}/${source.zip.filename}" basedir="${src.dir}" />
  </target>

  <!--=======================================================================
      source.targz
      
      Creates a gzipped tar of the project source for distribution
      ====================================================================-->
  <target name="source.targz" depends="init">
    <tar compression="gzip" destfile="${dist.dir}/${source.tar.filename}" basedir="${src.dir}" />
  </target>


  <!--=======================================================================
      clean-tests
      
      Removes all files related to tests
      ====================================================================-->
  <target name="clean-tests">
    <delete dir="${testbin.dir}" />
  </target>


  <!--=======================================================================
      init-tests
      
      Compiles project test source
      ====================================================================-->
  <target name="init-tests" depends="clean-tests">
    <mkdir dir="${testclasses.dir}" />
    <mkdir dir="${testsrc.dir}" />
  </target>


  <!--=======================================================================
      compile-tests
      
      Compiles project test source
      ====================================================================-->
  <target name="compile-tests" depends="init-tests">
    <javac destdir="${testclasses.dir}"
           debug="true"
           optimize="false"
           source="${javac.source}"
           target="${javac.target}"
           fork="true">
      <src path="${testsrc.dir}" />
      <classpath refid="test.classpath" />
    </javac>

    <!-- Copy the non-java files from the source directory to the test classes directory
-->
    <copy todir="${testclasses.dir}">
      <fileset dir="${testsrc.dir}">
        <exclude name="**/*.java" />
      </fileset>
    </copy>
  </target>


  <!--=======================================================================
      test
      
      Compiles and runs all the tests for the project
      ====================================================================-->
  <target name="test" depends="compile,compile-tests, init-test-reports" description="Compiles and runs unit tests">
    <junit maxmemory="${junit.maxmemory}"
           dir="${junit.base.dir}"
           fork="yes"
           forkmode="${junit.forkmode}"
           failureProperty="test.failed"
           haltonfailure="${junit.haltonfailure}"
           haltonerror="${junit.haltonerror}"
           printsummary="yes">
      <sysproperty key="java.awt.headless" value="${headless.unittest}" />
      
      <syspropertyset>
        <propertyref prefix="junit.sysprop." />
        <mapper type="glob" from="junit.sysprop.*" to="*"/>
      </syspropertyset>
      
      <classpath refid="test.classpath" />
      <formatter type="xml" />
      <test name="${testcase}" todir="${testreports.xml.dir}" if="testcase" />
      <batchtest fork="yes" todir="${testreports.xml.dir}" unless="testcase">
        <fileset dir="${testsrc.dir}" casesensitive="yes">
          <include name="**/*Test.java" />
        </fileset>
      </batchtest>
    </junit>

    <junitreport todir="${testreports.html.dir}">
      <fileset dir="${testreports.xml.dir}">
        <include name="TEST-*.xml" />
      </fileset>
      <report format="frames" todir="${testreports.html.dir}" />
    </junitreport>
  </target>


  <!--=======================================================================
    clean-test-reports

    Remove all xml and html JUnit test reports
    ====================================================================-->
  <target name="clean-test-reports">
    <delete dir="${testreports.xml.dir}" />
    <delete dir="${testreports.html.dir}" />
  </target>


  <!--=======================================================================
    init-test-reports

    Prepare directories for JUnit test reports
    ====================================================================-->
  <target name="init-test-reports" depends="clean-test-reports">
    <mkdir dir="${testreports.xml.dir}" />
    <mkdir dir="${testreports.html.dir}" />
  </target>

  <!--=======================================================================
      dist
      
      Creates a distribution of this project
      ====================================================================-->
  <target name="dist" depends="jar" description="Creates a distribution" />


  <!--=======================================================================
      dist-full
      
      Creates a distribution of this project including all sources needed
      to build as well as the resultant jar
      ====================================================================-->
  <target name="dist-full" depends="jar"
          description="Creates all the distributable items for this project">
    <!-- Create the required zip distribution which contains the entire project -->
    <zip destfile="${dist.dir}/${ivy.artifact.id}-${project.revision}.zip">
      <fileset dir="${basedir}">
        <exclude name="bin/"/>
        <exclude name="dist/"/>
        <exclude name="eclipse-bin/"/>
      </fileset>
      <zipfileset dir="${dist.dir}" includes="**/*.jar"/>
    </zip>
  </target>


  <!--=======================================================================
      javadoc
      
      Generates javadoc source documentation for this project
      ====================================================================-->
  <target name="javadoc" depends="javadoc.init, compile">
    <javadoc destdir="${javadoc.dir}/docs/api"
             access="public"
             source="6"
             use="true"
             notree="false"
             nonavbar="false"
             noindex="false"
             splitindex="true"
             author="true"
             version="true"
             maxmemory="256M"
             nodeprecatedlist="false"
             nodeprecated="false"
             packagenames="${javadoc.packagenames}"
             sourcepath="${src.dir}"
             doctitle="${impl.title} documentation">
      <link href="http://docs.oracle.com/javase/6/docs/api/" />
      <classpath refid="classpath" />
    </javadoc>
  </target>

  	
  <!--=======================================================================
	enunciate
        
	Generates enunciate documentation for the resoruce 
	classes comprising the BIServer REST api
  ====================================================================-->
  <target name="enunciate" depends="resolve-enunciate">
    <path id="enunciate.classpath">
      <fileset dir="${lib.dir}">
        <include name="*.jar" />
      	<exclude name="saxon*.jar" />
      </fileset>
      <dirset dir="${classes.dir}" />
      <fileset dir="${dist.dir}">
        <include name="*.jar" />
      </fileset>
      <fileset dir="${enunciate.home}/lib">
        <include name="*.jar" />
      </fileset>
    </path>

    <taskdef name="enunciate" classname="org.codehaus.enunciate.main.EnunciateTask">
      <classpath refid="enunciate.classpath" />
    </taskdef>

    <enunciate dir="${basedir}/src" 
               configFile="${basedir}/enunciate.xml" 
               generateDir="${enunciate.bin.dir}/generate" 
               compileDir="${enunciate.bin.dir}/compile" 
               buildDir="${enunciate.bin.dir}/build" 
               packageDir="${enunciate.bin.dir}/package" 
               verbose="true">
      <include name="**/*.java" />
      <!-- have to exclude class that contains jersey multipart endpoint until http://jira.codehaus.org/browse/ENUNCIATE-537 is fixed -->
      
      <classpath refid="enunciate.classpath" />
      <export artifactId="docs" destination="${dist.dir}/${enunciate.packagename}.zip" />
    </enunciate>
  </target>

  <!--=======================================================================
      dist-javadoc
      
      Generates zip and targz distributions of the javadoc
      ====================================================================-->
  <target name="dist-javadoc" depends="javadoc.zip, javadoc.targz" />


  <!--=======================================================================
      clean-javadoc
      
      Removes generated javadoc files (note, this does not remove javadoc distributions.
      Use clean-dist to remove artifacts from the dist.dir.
      ====================================================================-->
  <target name="clean-javadoc">
    <delete dir="${javadoc.dir}" />
  </target>


  <!--=======================================================================
      javadoc.init
      
      Creates directories for javadoc process
      ====================================================================-->
  <target name="javadoc.init" depends="clean-javadoc">
    <mkdir dir="${javadoc.dir}" />
  </target>


  <!--=======================================================================
      javadoc.zip
      
      Creates a zip of the javadoc for distribution
      ====================================================================-->
  <target name="javadoc.zip" depends="javadoc">
    <jar jarfile="${dist.dir}/${javadoc.zip.filename}"
         basedir="${javadoc.dir}"
         includes="**/*"
         excludes="**/Thumbs.db" />
  </target>


  <!--=======================================================================
      javadoc.targz
      
      Creates a gzipped tar of the javadoc for distribution
      ====================================================================-->
  <target name="javadoc.targz" depends="javadoc">
    <tar compression="gzip"
         destfile="${dist.dir}/${javadoc.tar.filename}"
         basedir="${javadoc.dir}"
         includes="**/*"
         excludes="**/Thumbs.db" />
  </target>


  <!--=======================================================================
      cobertura
      
      Runs tests in an instrumented environment and produces Cobertura test coverage reports
      ====================================================================-->
  <target name="cobertura"
          description="Runs tests in an instrumented environment and produces Cobertura test coverage reports"
          depends="clean-cobertura,install-cobertura,compile,compile-tests,cobertura.instrument-classes,cobertura.test-instrumented,cobertura.xml-report,cobertura.html-report" />


  <!--=======================================================================
      cobertura.instrument-classes
      
      Instruments the application classes used by Cobertura during cobertura.test-instrumented
      ====================================================================-->
  <target name="cobertura.instrument-classes" depends="cobertura.clean-instrumented-classes,install-cobertura,compile">
    <cobertura-instrument todir="${instrumented.classes.dir}" datafile="${cobertura.data.dir}/cobertura.ser">
      <ignore regex="org.apache.log4j.*" />
      <fileset dir="${classes.dir}">
        <!--
          Instrument all the application classes, but
          don't instrument the test classes.
        -->
        <include name="**/*.class" />
        <exclude name="**/*Test.class" />
      </fileset>

    </cobertura-instrument>
  </target>



  <!--=======================================================================
      install-cobertura
      
      Downloads and installs Cobertura ant tasks
      ====================================================================-->
  <target name="install-cobertura" depends="install-ivy">
    <taskdef-with-ivy organisation="net.sourceforge.cobertura" module="cobertura" revision="${cobertura.version}" resource="tasks.properties" classname="net.sourceforge.cobertura.ant.InstrumentTask"/>
  </target>


  <!--=======================================================================
      clean-cobertura
      
      Removes all files created by Cobertura code coverage utility
      ====================================================================-->
  <target name="clean-cobertura" depends="cobertura.clean-instrumented-classes,cobertura.clean-coverage-reports">
    <delete dir="${cobertura.data.dir}" />
  </target>

  <!--=======================================================================
      clean-sonar
      
      Removes the temporary file location for sonar files
      ====================================================================-->
  <target name="clean-sonar">
    <delete dir="${basedir}/.sonar" />
  </target>


  <!--=======================================================================
    cobertura.clean-instrumented-classes

    Remove the instrumented classes used by Cobertura
    ====================================================================-->
  <target name="cobertura.clean-instrumented-classes">
    <delete dir="${instrumented.classes.dir}" />
  </target>


  <!--=======================================================================
    cobertura.clean-coverage-reports

    Remove all xml and html Cobertura coverage reports
    ====================================================================-->
  <target name="cobertura.clean-coverage-reports">
    <delete dir="${coberturareports.xml.dir}" />
    <delete dir="${coberturareports.html.dir}" />
    <delete dir="${coberturareports.dir}" />
  </target>


  <!--=======================================================================
      cobertura.test-instrumented
      
      Runs tests against instrumented classes and generates xml and html JUnit test reports
      ====================================================================-->
  <target name="cobertura.test-instrumented"
          depends="init-test-reports,install-cobertura,compile,compile-tests,cobertura.instrument-classes">
    <mkdir dir="${instrumented.classes.dir}" />
    <path id="cobertura.classpath">
      <fileset dir="${subfloor.resources.dir}/cobertura-${cobertura.version}">
        <include name="*.jar" />
      </fileset>
    </path>
    <junit fork="yes"
           forkmode="${junit.forkmode}"
           dir="${junit.base.dir}"
           maxmemory="${junit.maxmemory}"
           failureProperty="test.failed"
           haltonerror="${junit.haltonerror}"
           haltonfailure="${junit.haltonfailure}">
      <sysproperty key="java.awt.headless" value="${headless.unittest}" />

      <!-- Specify the name of the coverage data file to use. -->
      <sysproperty key="net.sourceforge.cobertura.datafile" file="${cobertura.data.dir}/cobertura.ser" />

      <syspropertyset>
        <propertyref prefix="junit.sysprop." />
        <mapper type="glob" from="junit.sysprop.*" to="*"/>
      </syspropertyset>
      
      <!--
        Note the classpath order: instrumented classes are before the
        original (uninstrumented) classes.  This is important.
      -->
      <classpath location="${instrumented.classes.dir}" />
      <classpath refid="test.classpath" />
      <classpath refid="cobertura.classpath" />

      <formatter type="xml" />
      <test name="${testcase}" todir="${testreports.xml.dir}" if="testcase" />
      <batchtest todir="${testreports.xml.dir}" unless="testcase">
        <fileset dir="${testsrc.dir}" casesensitive="yes">
          <include name="**/*Test.java" />
        </fileset>
      </batchtest>
    </junit>

    <junitreport todir="${testreports.html.dir}">
      <fileset dir="${testreports.xml.dir}">
        <include name="TEST-*.xml" />
      </fileset>
      <report format="frames" todir="${testreports.html.dir}" />
    </junitreport>
  </target>


  <!--=======================================================================
      cobertura.xml-report
      
      Produces machine-readable xml Cobertura coverage report from results of instrumented tests
      ====================================================================-->
  <target name="cobertura.xml-report" depends="cobertura.test-instrumented">
    <cobertura-report destdir="${coberturareports.xml.dir}" datafile="${cobertura.data.dir}/cobertura.ser" format="xml">
      <fileset dir="${src.dir}">
        <include name="**/*.java" />
      </fileset>
    </cobertura-report>
  </target>


  <!--=======================================================================
      cobertura.html-report
      
      Produces human-readable html Cobertura coverage report from results of instrumented tests
      ====================================================================-->
  <target name="cobertura.html-report" depends="cobertura.test-instrumented">
    <cobertura-report destdir="${coberturareports.html.dir}"
                      datafile="${cobertura.data.dir}/cobertura.ser"
                      format="html">
      <fileset dir="${src.dir}">
        <include name="**/*.java" />
      </fileset>
    </cobertura-report>
  </target>

  <!--=======================================================================
        install-pentaho-ant-tasks
 
        Fetches and installs Pentaho Ant tasks
      ====================================================================-->
  <target name="install-pentaho-ant-tasks" depends="install-ivy">
    <taskdef-with-ivy task-name="dot-classpath" classname="org.pentaho.anttasks.DotClasspath" organisation="pentaho" module="pentaho-ant-tasks" revision="1.1" />
  </target>

  <!--=======================================================================
        create-dot-classpath
 
        Creates the Eclipse .classpath file from the resolved
        classpath from Ant.
      ====================================================================-->
  <target name="create-dot-classpath" depends="install-pentaho-ant-tasks,init">
    <dot-classpath>
      <!-- Include all lib dirs -->
      <classpath>
        <fileset dir="${devlib.dir}">
          <include name="*.jar" />
        </fileset>
        <fileset dir="${testlib.dir}">
          <include name="*.jar" />
        </fileset>
        <fileset dir="${lib.dir}">
          <include name="*.jar" />
        </fileset>
      </classpath>
    </dot-classpath>
  </target>


  <!--=======================================================================
        MACRO: taskdef-with-ivy
        Downloads (using IVY) and defines new Ant tasks
      
      NOTE: any task using this macro must depend on "install-antcontrib"
      
      parameters:
      task-name    - Name to give the new Ant task (only used if resource is not set)
      organisation - Artifact organization (for artifact resolution with IVY)
      module       - Artifact module (for artifact resolution with IVY)
      revision     - Artifact revision (for artifact resolution with IVY)
      classname    - Classname for the Ant task.  Used during taskdef and to check 
                     if we already have the libraries
      resource     - (optional) Resource defining the Ant task.  Used during taskdef
      ====================================================================-->
  <macrodef name="taskdef-with-ivy">
    <attribute name="task-name"
               description="Name to give the new Ant task (only used if resource is not set)"
               default="unset" />
    <attribute name="organisation" description="Artifact organization" />
    <attribute name="module" description="Artifact module" />
    <attribute name="revision" description="Artifact revision" />
    <attribute name="classname"
               description="Classname for the Ant task.  Used during taskdef and to check if we already have the libraries." />
    <attribute name="resource"
               description="(optional) Resource defining the Ant task.  Used during taskdef"
               default="unset" />
    <sequential>
      <mkdir dir="${subfloor.resources.dir}/@{module}-@{revision}/" />
      <!-- if the library does not exist, we must download it -->
      <if>
        <not>
          <and>
            <available file="${subfloor.resources.dir}/@{module}-@{revision}" />
            <available classname="@{classname}">
              <classpath>
                <fileset dir="${subfloor.resources.dir}/@{module}-@{revision}">
                  <include name="*.jar" />
                </fileset>
              </classpath>
            </available>
          </and>
        </not>
        <then>
          <ivy:retrieve inline="true"
              conf="default"
                        organisation="@{organisation}"
                        module="@{module}"
                        revision="@{revision}"
                        pattern="${subfloor.resources.dir}/@{module}-@{revision}/[module]-__-[revision](-[classifier]).[ext]" />
          <!-- in case the artifact pulls in an ant jar, remove it. they cause runtime conflicts -->
          <delete>
            <fileset dir="${subfloor.resources.dir}/@{module}-@{revision}">
              <include name="ant-__-*.jar" />
              <include name="ant-launcher-__-*.jar" />
            </fileset>
          </delete>
        </then>
      </if>
      <path id="taskdef.classpath">
        <fileset dir="${subfloor.resources.dir}/@{module}-@{revision}">
          <include name="*.jar" />
        </fileset>
      </path>
      <if>
        <equals arg1="@{resource}" arg2="unset" />
        <then>
          <taskdef classpathref="taskdef.classpath" name="@{task-name}" classname="@{classname}" />
        </then>
        <else>
          <taskdef classpathref="taskdef.classpath" resource="@{resource}" />
        </else>
      </if>
    </sequential>
  </macrodef>


  <!--=======================================================================
      Macro which will download the specified library. 
      
      NOTE: any task using this macro must depend on "install-antcontrib"
      
      parameters:
      name      - The name of the library (the filename w/o extension)
      url       - The URL from which the library will be downloaded
      resource  - The name of the resource which should be loaded
                  as a task definition 
      classname - A class file name which can be used to detect if the
                  property library exists
      extension - The extension of the library being downloaded 
                  (defaults to zip)
      ====================================================================-->
  <macrodef name="download-antlib">
    <attribute name="name" />
    <attribute name="url" />
    <attribute name="classname" />
    <attribute name="extension" default="zip" />
    <sequential>
      <mkdir dir="${subfloor.resources.dir}/@{name}/" />
      <!-- if the library does not exist, we must download it -->
      <if>
        <not>
          <and>
            <available file="${subfloor.resources.dir}/@{name}" />
            <available classname="@{classname}">
              <classpath>
                <fileset dir="${subfloor.resources.dir}/@{name}">
                  <include name="**/*.jar" />
                </fileset>
              </classpath>
            </available>
          </and>
        </not>
        <then>
          <!-- if it is a zip file, unzip it ... otherwise if a jar, just download it -->
          <if>
            <equals arg1="zip" arg2="@{extension}" />
            <then>
              <!-- download the source file to a temp directory -->
              <echo message="downloading library @{name} [@{name}.@{extension} from @{url}]" />
              <mkdir dir="${subfloor.tmp.dir}" />
              <get src="@{url}" dest="${subfloor.tmp.dir}/@{name}.@{extension}" usetimestamp="true" />
              <unzip src="${subfloor.tmp.dir}/@{name}.@{extension}"
                     dest="${subfloor.resources.dir}/@{name}"
                     overwrite="true" />
            </then>
            <else>
              <get src="@{url}" dest="${subfloor.resources.dir}/@{name}/@{name}.@{extension}" usetimestamp="true" />
            </else>
          </if>
        </then>
      </if>
    </sequential>
  </macrodef>

  <!--=======================================================================
    install-tattletale
    
    (Fetches and) installs TATTLETALE for use by this ant script
    ====================================================================-->
  <target name="install-tattletale" depends="install-antcontrib">
    <if>
      <istrue value="${tattletale.isinstalled}" />
      <then>
        <echo message="Skipping TATTLETALE install.  TATTLETALE has already been configured by the build" />
      </then>
      <else>
        <download-antlib name="tattletale"
                         url="${tattletale.url}"
                         classname="${tattletale.classname}" 
                         extension="zip"/>
                          
        <taskdef name="tattletale.report" classname="${tattletale.classname}">
          <classpath>
            <fileset dir="${subfloor.resources.dir}/tattletale">
              <include name="*.jar" />
            </fileset>
          </classpath>
        </taskdef>

        <property name="tattletale.isinstalled" value="true" />
      </else>
    </if>
  </target>
  
  <!--=======================================================================
    tattletale-report
    
    Generates a tattletale report for this project
    ====================================================================-->
  <target name="tattletale-report" depends="install-tattletale,jar">
    <tattletale.report source="${basedir}" destination="${tattletale.reports.dir}"/>
  </target>
  
<!--=======================================================================
    install-sonar
    
    (Fetches and) installs SONAR ant plugin for use by this ant script
    ====================================================================-->
  <target name="install-sonar" depends="install-antcontrib">
    <if>
      <istrue value="${sonar.isinstalled}" />
      <then>
        <echo message="Skipping SONAR install.  SONAR has already been configured by the build" />
      </then>
      <else>
        <download-antlib name="sonar"
                         url="${sonar.url}"
                         classname="${sonar.classname}" 
                         extension="jar"/>
                          
        <taskdef uri="antlib:org.sonar.ant" resource="org/sonar/ant/antlib.xml">
            <classpath>
              <fileset dir="${subfloor.resources.dir}/sonar">
                  <include name="*.jar" />
              </fileset>
            </classpath> 
        </taskdef>

        <property name="sonar.isinstalled" value="true" />
      </else>
    </if>
  </target>

  <!--=======================================================================
    sonar
      
    Execute the sonar analysis and publish to a sonar server specified by:
    sonar.jdbc.url
    sonar.jdbc.driverClassName
    sonar.jdbc.username
    sonar.jdbc.password
    sonar.host.url
    ====================================================================-->
  <target name="sonar" depends="install-sonar, compile, test, cobertura">
    <property name="sonar.sources" value="${src.dir}" />
    <property name="sonar.binaries" value="${classes.dir}" />
    <property name="sonar.tests" value="${testsrc.dir}" />
    <property name="sonar.libraries" value="${lib.dir}" />

    <property name="sonar.dynamicAnalysis" value="reuseReports" />
    <property name="sonar.cobertura.reportPath" value="${coberturareports.xml.dir}/coverage.xml" />
    <property name="sonar.surefire.reportsPath" value="${testreports.xml.dir}" />
    
    <sonar:sonar key="${ivy.artifact.group}:${ivy.artifact.id}" version="${project.revision}" xmlns:sonar="antlib:org.sonar.ant"/>
  </target>
  
</project>
